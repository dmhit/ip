(function () {
    // --- Конфигурация ---
    const CONFIG = {
        TOKEN: '{TOKEN}', // Плейсхолдер токена, заменяется загрузчиком
        TARGET_PATH: '/pl/metrika/user/',
        API_BASE: 'https://api.2ip.io', // Исправлено: убраны лишние пробелы
        CACHE_PREFIX: 'geo_ip_',
        DELAY_MS: 1000,
        RETRY_DELAY_MS: 1500,
        MAX_RETRIES: 7,
        AUTO_LOAD_COUNT: 7,
        TOGGLE_STORAGE_KEY: 'geoLookupEnabled',
        SUBTABLE_DEFAULT_COLSPAN: 7
    };

    // --- Валидация ---
    if (!window.location.pathname.startsWith(CONFIG.TARGET_PATH)) {
        console.log('Не на целевой странице.');
        return;
    }
    console.log('Secure context:', window.isSecureContext, 'Protocol:', location.protocol);

    // --- Вспомогательные функции ---
    const Utils = {
        isValidIP: (ip) => {
            const ipRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;
            return ipRegex.test(ip);
        },
        createNotification: (message, targetElement) => {
            const notification = document.createElement('div');
            notification.textContent = message;
            Object.assign(notification.style, {
                position: 'absolute',
                background: '#333',
                color: '#fff',
                padding: '5px 10px',
                borderRadius: '4px',
                zIndex: '1000',
                fontSize: '12px',
                left: `${targetElement.getBoundingClientRect().left + window.scrollX}px`,
                top: `${targetElement.getBoundingClientRect().bottom + window.scrollY + 5}px`
            });
            document.body.appendChild(notification);
            setTimeout(() => notification.remove(), 2000);
        },
        copyToClipboard: (text, targetElement) => {
            console.log(`Попытка копирования: ${text}`);
            try {
                if (typeof text !== 'string') throw new Error(`Некорректное значение для копирования: ${text}`);
                const textArea = document.createElement('textarea');
                textArea.value = text;
                textArea.style.cssText = 'position:fixed; opacity:0;';
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                console.log(`Скопировано в буфер обмена: ${text}`);
                Utils.createNotification(`Скопировано: ${text}`, targetElement);
            } catch (err) {
                console.error(`Ошибка копирования для ${text}:`, err);
                Utils.createNotification('Ошибка копирования', targetElement);
            } finally {
                if (textArea) document.body.removeChild(textArea);
            }
        }
    };

    // --- Кэширование ---
    const Cache = {
        get: (ip) => {
            const cached = sessionStorage.getItem(CONFIG.CACHE_PREFIX + ip);
            if (!cached) return null;
            const data = JSON.parse(cached);
            console.log(`Используем кэш для IP ${ip}:`, data);
            return data;
        },
        set: (ip, data) => {
            sessionStorage.setItem(CONFIG.CACHE_PREFIX + ip, JSON.stringify(data));
            console.log(`Сохранены кэшированные данные для IP ${ip}:`, data);
        }
    };

    // --- Очередь запросов ---
    const RequestQueue = (() => {
        const queue = [];
        let isProcessing = false;

        const process = async () => {
            if (isProcessing || queue.length === 0) return;
            isProcessing = true;

            const { url, resolve, reject, retries, startTime } = queue.shift();
            try {
                console.log(`Отправляем запрос: ${url}`);
                const response = await fetch(url);
                if (response.status === 429 && retries > 0) {
                    console.log(`429 для ${url}, повтор через ${CONFIG.RETRY_DELAY_MS} мс, осталось попыток: ${retries}`);
                    queue.unshift({ url, resolve, reject, retries: retries - 1, startTime });
                    setTimeout(process, CONFIG.RETRY_DELAY_MS);
                    isProcessing = false;
                    return;
                }
                if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                const data = await response.json();
                console.log(`Получены данные для ${url}:`, data);
                resolve(data);
            } catch (error) {
                console.error(`Ошибка для ${url}:`, error);
                reject(error);
            } finally {
                console.log(`Запрос ${url} занял ${Date.now() - startTime} мс, ждём ${CONFIG.DELAY_MS} мс`);
                setTimeout(() => {
                    isProcessing = false;
                    process();
                }, CONFIG.DELAY_MS);
            }
        };

        return {
            add: (url) => new Promise((resolve, reject) => {
                queue.push({ url, resolve, reject, retries: CONFIG.MAX_RETRIES, startTime: Date.now() });
                process();
            })
        };
    })();

    // --- API Функции ---
    const Api = {
        fetchGeo: async (ip) => {
            const cached = Cache.get(ip);
            if (cached) return cached;

            try {
                // Исправлено: убраны лишние пробелы в URL
                const data = await RequestQueue.add(`${CONFIG.API_BASE}/${ip}?token=${CONFIG.TOKEN}&lang=ru`);
                const result = {
                    country: `${data.country || 'N/A'} (${data.code || ''} ${data.emoji || ''})`,
                    city: `${data.city || 'N/A'} (${data.region || ''})`,
                    provider: 'N/A'
                };
                Cache.set(ip, result);
                return result;
            } catch (error) {
                return { country: 'Ошибка', city: 'Ошибка', provider: 'N/A' };
            }
        },
        fetchWhois: async (ip) => {
            try {
                // Исправлено: убраны лишние пробелы в URL
                const data = await RequestQueue.add(`${CONFIG.API_BASE}/whois/${ip}?token=${CONFIG.TOKEN}`);
                const provider = data.whois?.network?.name || 'N/A';
                const cached = Cache.get(ip) || { country: 'N/A', city: 'N/A', provider: 'N/A' };
                cached.provider = provider;
                Cache.set(ip, cached);
                return provider;
            } catch (error) {
                return 'N/A';
            }
        }
    };

    // --- Работа с DOM ---
    const DOM = {
        selectors: {
            mainTable: 'table.table.table-striped.table-bordered:not(.bg-gray)',
            paginationCurrent: '.pagination .active a[data-page]',
            mainTableRows: 'tbody tr:not(.row-hits)',
            subTableRows: 'tr.row-hits',
            geoTh: 'th[data-geo]',
            geoTd: 'td[data-geo]'
        },
        getMainTable: () => document.querySelector(DOM.selectors.mainTable),
        getMainHeaderRow: () => document.querySelector(`${DOM.selectors.mainTable} thead tr`),
        getMainBodyRows: () => Array.from(document.querySelectorAll(DOM.selectors.mainTableRows)),
        getSubTableRows: () => document.querySelectorAll(DOM.selectors.subTableRows),
        getIPCell: (row) => row.children[2],
        getIPFromRow: (row) => {
            const ipTd = DOM.getIPCell(row);
            return ipTd ? ipTd.textContent.trim() : null;
        },
        getGeoCells: (row) => ({
            country: row.querySelector('td[data-geo="country"]'),
            city: row.querySelector('td[data-geo="city"]'),
            provider: row.querySelector('td[data-geo="provider"]')
        }),
        addGeoHeaders: (headerRow, ipTh) => {
            if (!headerRow.querySelector('th[data-geo="country"]')) {
                console.log('Добавляем заголовки: Страна, Город, Провайдер');
                const countryTh = document.createElement('th');
                countryTh.textContent = 'Страна';
                countryTh.setAttribute('data-geo', 'country');
                ipTh.after(countryTh);

                const cityTh = document.createElement('th');
                cityTh.textContent = 'Город';
                cityTh.setAttribute('data-geo', 'city');
                countryTh.after(cityTh);

                const providerTh = document.createElement('th');
                providerTh.textContent = 'Провайдер';
                providerTh.setAttribute('data-geo', 'provider');
                cityTh.after(providerTh);
            }
        },
        // Исправлено: логика отображения содержимого ячеек теперь соответствует оригиналу
        createGeoCell: (geoType, ip, cachedData, isAutoLoadIP) => {
            const cell = document.createElement('td');
            cell.setAttribute('data-geo', geoType);

            if (cachedData) {
                // Если есть кэш
                if (geoType === 'provider' && cachedData.provider !== 'N/A') {
                    cell.innerHTML = cachedData.provider;
                } else if (geoType === 'country' || geoType === 'city') {
                    cell.innerHTML = cachedData[geoType];
                } else {
                    // Для provider, если кэш есть, но provider = N/A
                    const loadButton = document.createElement('button');
                    loadButton.textContent = 'Загрузить';
                    loadButton.setAttribute('data-ip', ip);
                    loadButton.onclick = async () => {
                        loadButton.disabled = true;
                        loadButton.textContent = 'Загрузка...';
                        const updatedProvider = await Api.fetchWhois(ip);
                        // Обновление через DOM, как в оригинале
                        DOM.getMainBodyRows().forEach(r => {
                            if (DOM.getIPFromRow(r) === ip) {
                                r.querySelector('td[data-geo="provider"]').innerHTML = updatedProvider;
                            }
                        });
                    };
                    cell.appendChild(loadButton);
                }
            } else {
                // Если кэша нет
                if (geoType === 'country' || geoType === 'city') {
                    if (isAutoLoadIP) {
                        // Для автозагрузки показываем "Загрузка..."
                        cell.textContent = 'Загрузка...';
                    } else {
                        // Для остальных показываем кнопку "Загрузить"
                        const loadButton = document.createElement('button');
                        loadButton.textContent = 'Загрузить';
                        loadButton.setAttribute('data-ip', ip);
                        loadButton.onclick = async () => {
                            loadButton.disabled = true;
                            loadButton.textContent = 'Загрузка...';
                            const geoData = await Api.fetchGeo(ip);
                            DOM.getMainBodyRows().forEach(r => {
                                if (DOM.getIPFromRow(r) === ip) {
                                    r.querySelector('td[data-geo="country"]').innerHTML = geoData.country;
                                    r.querySelector('td[data-geo="city"]').innerHTML = geoData.city;
                                }
                            });
                        };
                        cell.appendChild(loadButton);
                    }
                } else { // geoType === 'provider'
                    // Для provider всегда кнопка, если кэша нет или provider N/A
                    const loadButton = document.createElement('button');
                    loadButton.textContent = 'Загрузить';
                    loadButton.setAttribute('data-ip', ip);
                    loadButton.onclick = async () => {
                        loadButton.disabled = true;
                        loadButton.textContent = 'Загрузка...';
                        const updatedProvider = await Api.fetchWhois(ip);
                        // Обновление через DOM, как в оригинале
                        DOM.getMainBodyRows().forEach(r => {
                            if (DOM.getIPFromRow(r) === ip) {
                                r.querySelector('td[data-geo="provider"]').innerHTML = updatedProvider;
                            }
                        });
                    };
                    cell.appendChild(loadButton);
                }
            }
            return cell;
        },
        addIPCellStyling: (ipTd, ip) => {
            ipTd.style.cursor = 'pointer';
            ipTd.style.textDecoration = 'underline';
            ipTd.style.color = 'blue';
            ipTd.title = 'Кликните, чтобы скопировать &dev-request-ip=' + ip;
            ipTd.onclick = () => Utils.copyToClipboard(`&dev-request-ip=${ip}`, ipTd);
        },
        adjustSubtableColspan: () => {
            const headerRow = DOM.getMainHeaderRow();
            if (!headerRow) return false;
            const totalColumns = headerRow.children.length;
            let adjusted = false;
            DOM.getSubTableRows().forEach(subRow => {
                const subTd = subRow.querySelector('td[colspan]');
                if (subTd && subTd.getAttribute('colspan') !== totalColumns.toString()) {
                    console.log(`Корректируем colspan для подтаблицы: с ${subTd.getAttribute('colspan')} на ${totalColumns}`);
                    subTd.setAttribute('colspan', totalColumns);
                    adjusted = true;
                }
            });
            return adjusted;
        },
        disableGeoFeatures: (observer) => {
            console.log('Отключаем функциональность Geo Lookup');
            const table = DOM.getMainTable();
            if (table) {
                // Удаляем заголовки
                const headerRow = table.querySelector('thead tr');
                if (headerRow) {
                    ['country', 'city', 'provider'].forEach(geoType => {
                        const th = headerRow.querySelector(`th[data-geo="${geoType}"]`);
                        if (th) th.remove();
                    });
                }
                // Удаляем ячейки и обработчики кликов
                DOM.getMainBodyRows().forEach(row => {
                    const ipTd = DOM.getIPCell(row);
                    ['country', 'city', 'provider'].forEach(geoType => {
                        const td = row.querySelector(`td[data-geo="${geoType}"]`);
                        if (td) td.remove();
                    });
                    if (ipTd) {
                        ipTd.style.cursor = '';
                        ipTd.style.textDecoration = '';
                        ipTd.style.color = '';
                        ipTd.title = '';
                        ipTd.onclick = null;
                    }
                });
                // Сбрасываем colspan подтаблиц
                DOM.getSubTableRows().forEach(subRow => {
                    const subTd = subRow.querySelector('td[colspan]');
                    if (subTd && subTd.getAttribute('colspan') !== CONFIG.SUBTABLE_DEFAULT_COLSPAN.toString()) {
                        console.log(`Сбрасываем colspan для подтаблицы: с ${subTd.getAttribute('colspan')} на ${CONFIG.SUBTABLE_DEFAULT_COLSPAN}`);
                        subTd.setAttribute('colspan', CONFIG.SUBTABLE_DEFAULT_COLSPAN);
                    }
                });
            }
            observer.disconnect();
            console.log('MutationObserver отключён.');
        }
    };

    // --- Логика инициализации ---
    let isProcessingTable = false;
    const initGeoLookup = () => {
        if (isProcessingTable) {
            console.log('Таблица уже обрабатывается, пропускаем.');
            return false;
        }

        const table = DOM.getMainTable();
        if (!table) {
            console.log('Главная таблица ещё не найдена, ждём...');
            return false;
        }

        isProcessingTable = true;
        console.log('Главная таблица найдена, запускаем обработку.');

        const thead = table.querySelector('thead');
        const tbody = table.querySelector('tbody');
        if (!thead || !tbody) {
            console.log('thead или tbody не найдены.');
            isProcessingTable = false;
            return true;
        }

        const headerRow = thead.querySelector('tr');
        const ipTh = headerRow.children[2];
        if (!ipTh) {
            console.log('th для IP не найден.');
            isProcessingTable = false;
            return true;
        }

        DOM.addGeoHeaders(headerRow, ipTh);

        const rows = DOM.getMainBodyRows();
        const uniqueIPs = new Set();
        rows.forEach(row => {
            const ip = DOM.getIPFromRow(row);
            if (ip && Utils.isValidIP(ip)) uniqueIPs.add(ip);
        });

        const pageElement = document.querySelector(DOM.selectors.paginationCurrent);
        const currentPage = pageElement ? (parseInt(pageElement.getAttribute('data-page')) + 1).toString() : '1';
        const autoLoadIPs = currentPage === '1' ? Array.from(uniqueIPs).slice(0, CONFIG.AUTO_LOAD_COUNT) : [];

        if (autoLoadIPs.length > 0) {
            console.log(`Найдено ${uniqueIPs.size} уникальных IP, страница ${currentPage}, автоматически загружаем ${autoLoadIPs.length}:`, autoLoadIPs);
        }

        rows.forEach(row => {
            const ip = DOM.getIPFromRow(row);
            const { country: countryTd, city: cityTd, provider: providerTd } = DOM.getGeoCells(row);

            if (countryTd && cityTd && providerTd &&
                countryTd.innerHTML && cityTd.innerHTML && providerTd.innerHTML &&
                countryTd.innerHTML !== 'Загрузка...' && cityTd.innerHTML !== 'Загрузка...') {
                console.log(`Пропускаем строку для IP ${ip}: данные уже заполнены`);
                return;
            }

            if (!countryTd) { // Если ячейка страны не существует, значит и остальные не существуют
                const cached = ip && Utils.isValidIP(ip) ? Cache.get(ip) : null;
                const isAutoLoad = autoLoadIPs.includes(ip);

                if (ip && Utils.isValidIP(ip)) {
                    DOM.addIPCellStyling(DOM.getIPCell(row), ip);
                }

                // Исправлено: передаём isAutoLoad в createGeoCell
                const newCountryTd = DOM.createGeoCell('country', ip, cached, isAutoLoad);
                const newCityTd = DOM.createGeoCell('city', ip, cached, isAutoLoad);
                const newProviderTd = DOM.createGeoCell('provider', ip, cached, false); // Для provider автозагрузка не нужна

                if (ip && Utils.isValidIP(ip)) {
                    DOM.getIPCell(row).after(newCountryTd, newCityTd, newProviderTd);
                }
            }
        });

        // Автоматическая загрузка
        const processIP = async (ip) => {
            console.log(`Начинаем обработку IP ${ip}`);
            const geoData = await Api.fetchGeo(ip);
            rows.forEach(row => {
                const ipTd = DOM.getIPCell(row);
                if (ipTd && ipTd.textContent.trim() === ip) {
                    const { country: countryTd, city: cityTd } = DOM.getGeoCells(row);
                    if (countryTd.innerHTML && cityTd.innerHTML && 
                        countryTd.innerHTML !== 'Загрузка...' && cityTd.innerHTML !== 'Загрузка...') {
                        console.log(`Пропускаем обновление для IP ${ip}: данные уже есть`);
                        return;
                    }
                    console.log(`Обновляем строку для IP ${ip}:`, geoData);
                    if (countryTd) countryTd.innerHTML = geoData.country;
                    if (cityTd) cityTd.innerHTML = geoData.city;
                }
            });
        };

        if (autoLoadIPs.length > 0) {
            let index = 0;
            const processNext = () => {
                if (index >= autoLoadIPs.length) {
                    console.log('Автоматическая обработка первых 7 IP завершена.');
                    isProcessingTable = false;
                    DOM.adjustSubtableColspan();
                    return;
                }
                const ip = autoLoadIPs[index];
                console.log(`Запускаем processIP для ${ip}`);
                processIP(ip).then(() => {
                    console.log(`Обработан IP ${ip}, переходим к следующему (${index + 1}/${autoLoadIPs.length})`);
                    index++;
                    processNext();
                }).catch(error => {
                    console.error(`Ошибка в processNext для IP ${ip}:`, error);
                    rows.forEach(row => {
                        const ipTd = DOM.getIPCell(row);
                        if (ipTd && ipTd.textContent.trim() === ip) {
                            DOM.getGeoCells(row).country.innerHTML = 'Ошибка';
                            DOM.getGeoCells(row).city.innerHTML = 'Ошибка';
                            console.log(`Установлена ошибка для IP ${ip}`);
                        }
                    });
                    index++;
                    processNext();
                });
            };
            console.log('Запускаем автоматическую загрузку первых 7 IP');
            processNext();
        } else {
            isProcessingTable = false;
            DOM.adjustSubtableColspan();
        }
        return true;
    };

    // --- Тумблер ---
    const createToggle = (observer) => {
        const toggleContainer = document.createElement('label');
        Object.assign(toggleContainer.style, {
            position: 'fixed',
            right: '1%',
            top: '15%',
            zIndex: '1000',
            display: 'flex',
            alignItems: 'center',
            cursor: 'pointer'
        });

        const toggleInput = document.createElement('input');
        toggleInput.type = 'checkbox';
        toggleInput.style.cssText = 'width: 20px; height: 20px; margin-right: 1px; cursor: pointer;';

        const toggleLabel = document.createElement('span');
        toggleLabel.textContent = 'Выкл/Вкл';
        toggleLabel.style.cssText = 'font-size: 16px; color: #333;';

        toggleContainer.appendChild(toggleInput);
        toggleContainer.appendChild(toggleLabel);
        document.body.appendChild(toggleContainer);

        const isEnabled = sessionStorage.getItem(CONFIG.TOGGLE_STORAGE_KEY) !== 'false';
        toggleInput.checked = isEnabled;

        const updateState = (enable) => {
            sessionStorage.setItem(CONFIG.TOGGLE_STORAGE_KEY, enable.toString());
            if (enable) {
                console.log('Включаем Geo Lookup');
                initGeoLookup();
                DOM.adjustSubtableColspan();
                observer.observe(targetNode, { childList: true, subtree: true });
            } else {
                console.log('Выключаем Geo Lookup');
                DOM.disableGeoFeatures(observer);
            }
        };

        updateState(isEnabled);

        toggleInput.addEventListener('change', (e) => updateState(e.target.checked));
    };

    // --- Observer ---
    const targetNode = document.querySelector('#tabContentVisits') || document.body;
    const observer = new MutationObserver((mutations) => {
        if (isProcessingTable) {
            console.log('MutationObserver: Таблица обрабатывается, пропускаем изменения.');
            return;
        }

        let tableChanged = false;
        let subtableAdded = false;

        for (const mutation of mutations) {
            if (mutation.addedNodes.length || mutation.removedNodes.length) {
                const mainTableChanged = Array.from(mutation.addedNodes).some(node =>
                    node.nodeType === 1 && (
                        node.matches(DOM.selectors.mainTable) ||
                        node.querySelector(DOM.selectors.mainTable) ||
                        (node.matches('tbody') && node.closest(DOM.selectors.mainTable) &&
                         Array.from(node.querySelectorAll(DOM.selectors.mainTableRows)).some(tr => tr.querySelector('td'))) ||
                        (node.matches(DOM.selectors.mainTableRows) && node.closest(DOM.selectors.mainTable) && node.querySelector('td'))
                    )
                ) || Array.from(mutation.removedNodes).some(node =>
                    node.nodeType === 1 && (
                        node.matches(DOM.selectors.mainTable) ||
                        node.querySelector(DOM.selectors.mainTable) ||
                        (node.matches('tbody') && node.closest(DOM.selectors.mainTable) &&
                         Array.from(node.querySelectorAll(DOM.selectors.mainTableRows)).some(tr => tr.querySelector('td'))) ||
                        (node.matches(DOM.selectors.mainTableRows) && node.closest(DOM.selectors.mainTable) && node.querySelector('td'))
                    )
                );

                const subTableChanged = Array.from(mutation.addedNodes).some(node =>
                    node.nodeType === 1 && (
                        node.matches(DOM.selectors.subTableRows) ||
                        node.querySelector(DOM.selectors.subTableRows) ||
                        node.matches('table.bg-gray') ||
                        node.querySelector('table.bg-gray')
                    )
                );

                if (mainTableChanged) tableChanged = true;
                if (subTableChanged) subtableAdded = true;
            }
        }

        if (tableChanged) {
            console.log('Обнаружено изменение в главной таблице, запускаем initGeoLookup.');
            initGeoLookup();
        } else if (subtableAdded) {
            DOM.adjustSubtableColspan();
        }
    });

    // --- Инициализация ---
    createToggle(observer);
})();

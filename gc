(function() {
    // Плейсхолдер токена, заменяется загрузчиком
    const TOKEN = '{TOKEN}';

    // Проверяем, соответствует ли текущая страница шаблону
    if (!window.location.pathname.startsWith('/pl/metrika/user/')) {
        console.log('Не на целевой странице.');
        return;
    }

    // Логируем HTTPS-контекст для отладки
    console.log('Secure context:', window.isSecureContext, 'Protocol:', location.protocol);

    // Функция для проверки валидности IP-адреса
    function isValidIP(ip) {
        const ipRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;
        return ipRegex.test(ip);
    }

    // Функция для кэширования данных в sessionStorage
    const cacheKeyPrefix = 'geo_ip_';
    function getCachedGeo(ip) {
        const cached = sessionStorage.getItem(cacheKeyPrefix + ip);
        if (!cached) return null;
        const data = JSON.parse(cached);
        console.log(`Используем кэш для IP ${ip}:`, data);
        return data;
    }
    function setCachedGeo(ip, data) {
        sessionStorage.setItem(cacheKeyPrefix + ip, JSON.stringify(data));
        console.log(`Сохранены кэшированные данные для IP ${ip}:`, data);
    }

    // Глобальная очередь запросов
    const requestQueue = [];
    let isProcessingQueue = false;
    const delay = 1000; // Фиксированный интервал 1000 мс
    const retryDelay = 1500; // 1.5 секунды при 429
    const maxRetries = 7;

    async function processQueue() {
        if (isProcessingQueue || requestQueue.length === 0) return;
        isProcessingQueue = true;

        const { url, resolve, reject, retries, startTime } = requestQueue.shift();
        try {
            console.log(`Отправляем запрос: ${url}`);
            const response = await fetch(url);
            if (response.status === 429 && retries > 0) {
                console.log(`429 для ${url}, повтор через ${retryDelay} мс, осталось попыток: ${retries}`);
                requestQueue.unshift({ url, resolve, reject, retries: retries - 1, startTime });
                setTimeout(processQueue, retryDelay);
                isProcessingQueue = false;
                return;
            }
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            const data = await response.json();
            console.log(`Получены данные для ${url}:`, data);
            resolve(data);
        } catch (error) {
            console.error(`Ошибка для ${url}:`, error);
            reject(error);
        } finally {
            console.log(`Запрос ${url} занял ${Date.now() - startTime} мс, ждём ${delay} мс`);
            setTimeout(() => {
                isProcessingQueue = false;
                processQueue();
            }, delay);
        }
    }

    function queueRequest(url) {
        return new Promise((resolve, reject) => {
            requestQueue.push({ url, resolve, reject, retries: maxRetries, startTime: Date.now() });
            processQueue();
        });
    }

    async function fetchGeo(ip) {
        const cached = getCachedGeo(ip);
        if (cached) return cached;

        try {
            const data = await queueRequest(`https://api.2ip.io/${ip}?token=${TOKEN}&lang=ru`);
            const result = {
                country: `${data.country || 'N/A'} (${data.code || ''} ${data.emoji || ''})`,
                city: `${data.city || 'N/A'} (${data.region || ''})`,
                provider: 'N/A'
            };
            setCachedGeo(ip, result);
            return result;
        } catch (error) {
            return { country: 'Ошибка', city: 'Ошибка', provider: 'N/A' };
        }
    }

    async function fetchWhois(ip) {
        try {
            const data = await queueRequest(`https://api.2ip.io/whois/${ip}?token=${TOKEN}`);
            const provider = data.whois?.network?.name || 'N/A';
            const cached = getCachedGeo(ip) || { country: 'N/A', city: 'N/A', provider: 'N/A' };
            cached.provider = provider;
            setCachedGeo(ip, cached);
            return provider;
        } catch (error) {
            return 'N/A';
        }
    }

    // Функция для отображения временного уведомления
    function showNotification(message, targetElement) {
        const notification = document.createElement('div');
        notification.textContent = message;
        notification.style.position = 'absolute';
        notification.style.background = '#333';
        notification.style.color = '#fff';
        notification.style.padding = '5px 10px';
        notification.style.borderRadius = '4px';
        notification.style.zIndex = '1000';
        notification.style.fontSize = '12px';

        const rect = targetElement.getBoundingClientRect();
        notification.style.left = `${rect.left + window.scrollX}px`;
        notification.style.top = `${rect.bottom + window.scrollY + 5}px`;

        document.body.appendChild(notification);
        setTimeout(() => {
            notification.remove();
        }, 2000);
    }

    // Функция копирования в буфер обмена
    function copyToClipboard(text, targetElement) {
        console.log(`Попытка копирования: ${text}`);
        try {
            if (typeof text !== 'string') {
                throw new Error(`Некорректное значение для копирования: ${text}`);
            }
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.opacity = '0';
            document.body.appendChild(textArea);
            textArea.select();
            try {
                document.execCommand('copy');
                console.log(`Скопировано в буфер обмена: ${text}`);
                showNotification(`Скопировано: ${text}`, targetElement);
            } catch (err) {
                console.error(`Ошибка копирования для ${text}:`, err);
                showNotification('Ошибка копирования', targetElement);
            }
            document.body.removeChild(textArea);
        } catch (error) {
            console.error(`Ошибка копирования для ${text}:`, error);
            showNotification('Ошибка копирования', targetElement);
        }
    }

    // Флаг для предотвращения зацикливания
    let isProcessingTable = false;

    // Функция для корректировки colspan в подтаблицах
    function adjustSubtableColspan() {
        const headerRow = document.querySelector('table.table.table-striped.table-bordered:not(.bg-gray) thead tr');
        if (!headerRow) return false;

        const totalColumns = headerRow.children.length;
        const subRows = document.querySelectorAll('tr.row-hits');
        let adjusted = false;
        subRows.forEach(subRow => {
            const subTd = subRow.querySelector('td[colspan]');
            if (subTd && subTd.getAttribute('colspan') !== totalColumns.toString()) {
                console.log(`Корректируем colspan для подтаблицы: с ${subTd.getAttribute('colspan')} на ${totalColumns}`);
                subTd.setAttribute('colspan', totalColumns);
                adjusted = true;
            }
        });
        return adjusted;
    }

    // Функция, которая запускает логику, когда таблица найдена
    function initGeoLookup() {
        if (isProcessingTable) {
            console.log('Таблица уже обрабатывается, пропускаем.');
            return false;
        }

        const table = document.querySelector('table.table.table-striped.table-bordered:not(.bg-gray)');
        if (!table) {
            console.log('Главная таблица ещё не найдена, ждём...');
            return false;
        }

        isProcessingTable = true;
        console.log('Главная таблица найдена, запускаем обработку.');

        const thead = table.querySelector('thead');
        const tbody = table.querySelector('tbody');
        if (!thead || !tbody) {
            console.log('thead или tbody не найдены.');
            isProcessingTable = false;
            return true;
        }

        // Добавляем новые th элементы после столбца IP (индекс 2), если их ещё нет
        const headerRow = thead.querySelector('tr');
        const ipTh = headerRow.children[2];
        if (!ipTh) {
            console.log('th для IP не найден.');
            isProcessingTable = false;
            return true;
        }

        if (!headerRow.querySelector('th[data-geo="country"]')) {
            console.log('Добавляем заголовки: Страна, Город, Провайдер');
            const countryTh = document.createElement('th');
            countryTh.textContent = 'Страна';
            countryTh.setAttribute('data-geo', 'country');
            ipTh.after(countryTh);

            const cityTh = document.createElement('th');
            cityTh.textContent = 'Город';
            cityTh.setAttribute('data-geo', 'city');
            countryTh.after(cityTh);

            const providerTh = document.createElement('th');
            providerTh.textContent = 'Провайдер';
            providerTh.setAttribute('data-geo', 'provider');
            cityTh.after(providerTh);
        }

        // Собираем уникальные IP-адреса только из строк главной таблицы
        const rows = Array.from(tbody.querySelectorAll('tr:not(.row-hits)'));
        const uniqueIPs = new Set();
        rows.forEach(row => {
            const ipTd = row.children[2];
            if (ipTd) {
                const ip = ipTd.textContent.trim();
                if (ip && isValidIP(ip)) {
                    uniqueIPs.add(ip);
                }
            }
        });

        // Определяем текущую страницу
        const pageElement = document.querySelector('.pagination .active a[data-page]');
        const currentPage = pageElement ? (parseInt(pageElement.getAttribute('data-page')) + 1).toString() : '1';
        const autoLoadIPs = currentPage === '1' ? Array.from(uniqueIPs).slice(0, 7) : [];

        // Логируем только если есть IP для автозагрузки
        if (autoLoadIPs.length > 0) {
            console.log(`Найдено ${uniqueIPs.size} уникальных IP, страница ${currentPage}, автоматически загружаем ${autoLoadIPs.length}:`, autoLoadIPs);
        }

        // Добавляем ячейки только для строк, где их ещё нет
        const addedIPs = new Set();
        rows.forEach(row => {
            const ipTd = row.children[2];
            const ip = ipTd?.textContent.trim();
            const countryTd = row.querySelector('td[data-geo="country"]');
            const cityTd = row.querySelector('td[data-geo="city"]');
            const providerTd = row.querySelector('td[data-geo="provider"]');

            // Пропускаем, если ячейки уже заполнены и не в состоянии "Загрузка..."
            if (countryTd && cityTd && providerTd &&
                countryTd.innerHTML && cityTd.innerHTML && providerTd.innerHTML &&
                countryTd.innerHTML !== 'Загрузка...' && cityTd.innerHTML !== 'Загрузка...') {
                console.log(`Пропускаем строку для IP ${ip}: данные уже заполнены`);
                return;
            }

            if (!countryTd) {
                if (ip && isValidIP(ip) && !addedIPs.has(ip)) {
                    console.log(`Добавляем ячейки для IP ${ip}`);
                    addedIPs.add(ip);
                }
                if (ip && isValidIP(ip)) {
                    ipTd.style.cursor = 'pointer';
                    ipTd.style.textDecoration = 'underline';
                    ipTd.style.color = 'blue';
                    ipTd.title = 'Кликните, чтобы скопировать &dev-request-ip=' + ip;
                    ipTd.onclick = () => copyToClipboard(`&dev-request-ip=${ip}`, ipTd);
                }
                const newCountryTd = document.createElement('td');
                newCountryTd.setAttribute('data-geo', 'country');
                const newCityTd = document.createElement('td');
                newCityTd.setAttribute('data-geo', 'city');
                const newProviderTd = document.createElement('td');
                newProviderTd.setAttribute('data-geo', 'provider');

                const cached = ip && isValidIP(ip) ? getCachedGeo(ip) : null;
                if (cached) {
                    newCountryTd.innerHTML = cached.country;
                    newCityTd.innerHTML = cached.city;
                    if (cached.provider !== 'N/A') {
                        newProviderTd.innerHTML = cached.provider;
                    } else {
                        const loadProviderButton = document.createElement('button');
                        loadProviderButton.textContent = 'Загрузить';
                        loadProviderButton.setAttribute('data-ip', ip);
                        loadProviderButton.onclick = async () => {
                            loadProviderButton.disabled = true;
                            loadProviderButton.textContent = 'Загрузка...';
                            const ip = loadProviderButton.getAttribute('data-ip');
                            const provider = await fetchWhois(ip);
                            rows.forEach(r => {
                                if (r.children[2].textContent.trim() === ip) {
                                    r.querySelector('td[data-geo="provider"]').innerHTML = provider;
                                }
                            });
                        };
                        newProviderTd.appendChild(loadProviderButton);
                    }
                } else {
                    if (ip && isValidIP(ip) && autoLoadIPs.includes(ip)) {
                        newCountryTd.textContent = 'Загрузка...';
                        newCityTd.textContent = 'Загрузка...';
                    } else if (ip && isValidIP(ip)) {
                        const loadGeoButton = document.createElement('button');
                        loadGeoButton.textContent = 'Загрузить';
                        loadGeoButton.setAttribute('data-ip', ip);
                        loadGeoButton.onclick = async () => {
                            loadGeoButton.disabled = true;
                            loadGeoButton.textContent = 'Загрузка...';
                            const ip = loadGeoButton.getAttribute('data-ip');
                            const geoData = await fetchGeo(ip);
                            rows.forEach(r => {
                                if (r.children[2].textContent.trim() === ip) {
                                    r.querySelector('td[data-geo="country"]').innerHTML = geoData.country;
                                    r.querySelector('td[data-geo="city"]').innerHTML = geoData.city;
                                }
                            });
                        };
                        newCountryTd.appendChild(loadGeoButton);
                        newCityTd.textContent = 'Загрузка...';
                    }
                    if (ip && isValidIP(ip)) {
                        const loadProviderButton = document.createElement('button');
                        loadProviderButton.textContent = 'Загрузить';
                        loadProviderButton.setAttribute('data-ip', ip);
                        loadProviderButton.onclick = async () => {
                            loadProviderButton.disabled = true;
                            loadProviderButton.textContent = 'Загрузка...';
                            const ip = loadProviderButton.getAttribute('data-ip');
                            const provider = await fetchWhois(ip);
                            rows.forEach(r => {
                                if (r.children[2].textContent.trim() === ip) {
                                    r.querySelector('td[data-geo="provider"]').innerHTML = provider;
                                }
                            });
                        };
                        newProviderTd.appendChild(loadProviderButton);
                    }
                }

                if (ip && isValidIP(ip)) {
                    ipTd.after(newCountryTd);
                    newCountryTd.after(newCityTd);
                    newCityTd.after(newProviderTd);
                }
            }
        });

        // Автоматическая загрузка первых 7 IP (только на первой странице)
        async function processIP(ip) {
            console.log(`Начинаем обработку IP ${ip}`);
            const geoData = await fetchGeo(ip);
            rows.forEach(row => {
                const ipTd = row.children[2];
                if (ipTd && ipTd.textContent.trim() === ip) {
                    const countryTd = row.querySelector('td[data-geo="country"]');
                    const cityTd = row.querySelector('td[data-geo="city"]');
                    if (countryTd.innerHTML && cityTd.innerHTML && 
                        countryTd.innerHTML !== 'Загрузка...' && cityTd.innerHTML !== 'Загрузка...') {
                        console.log(`Пропускаем обновление для IP ${ip}: данные уже есть`);
                        return;
                    }
                    console.log(`Обновляем строку для IP ${ip}:`, geoData);
                    if (countryTd) {
                        countryTd.innerHTML = geoData.country;
                        console.log(`Установлено country для IP ${ip}: ${countryTd.innerHTML}`);
                    }
                    if (cityTd) {
                        cityTd.innerHTML = geoData.city;
                        console.log(`Установлено city для IP ${ip}: ${cityTd.innerHTML}`);
                    }
                }
            });
        }

        if (autoLoadIPs.length > 0) {
            let index = 0;
            function processNext() {
                if (index >= autoLoadIPs.length) {
                    console.log('Автоматическая обработка первых 7 IP завершена.');
                    isProcessingTable = false;
                    adjustSubtableColspan();
                    return;
                }

                const ip = autoLoadIPs[index];
                console.log(`Запускаем processIP для ${ip}`);
                processIP(ip).then(() => {
                    index++;
                    console.log(`Обработан IP ${ip}, переходим к следующему (${index}/${autoLoadIPs.length})`);
                    processNext();
                }).catch(error => {
                    console.error(`Ошибка в processNext для IP ${ip}:`, error);
                    rows.forEach(row => {
                        const ipTd = row.children[2];
                        if (ipTd && ipTd.textContent.trim() === ip) {
                            row.querySelector('td[data-geo="country"]').innerHTML = 'Ошибка';
                            row.querySelector('td[data-geo="city"]').innerHTML = 'Ошибка';
                            console.log(`Установлено ошибка для IP ${ip}`);
                        }
                    });
                    index++;
                    console.log(`Ошибка для IP ${ip}, переходим к следующему (${index}/${autoLoadIPs.length})`);
                    processNext();
                });
            }

            console.log('Запускаем автоматическую загрузку первых 7 IP');
            processNext();
        } else {
            isProcessingTable = false;
            adjustSubtableColspan();
        }

        return true;
    }

    // Запускаем сразу, если таблица уже есть
    initGeoLookup();
    adjustSubtableColspan();

    // Настраиваем MutationObserver для отслеживания изменений в #tabContentVisits
    const targetNode = document.querySelector('#tabContentVisits') || document.body;
    const observer = new MutationObserver((mutations) => {
        if (isProcessingTable) {
            console.log('MutationObserver: Таблица обрабатывается, пропускаем изменения.');
            return;
        }

        let tableChanged = false;
        let subtableAdded = false;

        for (const mutation of mutations) {
            if (mutation.addedNodes.length || mutation.removedNodes.length) {
                // Проверяем изменения, связанные с заменой главной таблицы или её содержимого
                const mainTableChanged = Array.from(mutation.addedNodes).some(node => 
                    node.nodeType === 1 && (
                        // Новая главная таблица или её фрагмент
                        node.matches('table.table.table-striped.table-bordered:not(.bg-gray)') ||
                        node.querySelector('table.table.table-striped.table-bordered:not(.bg-gray)') ||
                        // Замена tbody внутри главной таблицы
                        (node.matches('tbody') && node.closest('table.table.table-striped.table-bordered:not(.bg-gray)') &&
                         // Проверяем, что изменения в tbody не связаны только с row-hits
                         Array.from(node.querySelectorAll('tr')).some(tr => !tr.classList.contains('row-hits'))) ||
                        // Добавление строк, не являющихся row-hits, внутри главной таблицы
                        (node.matches('tr:not(.row-hits)') && node.closest('table.table.table-striped.table-bordered:not(.bg-gray)'))
                    )
                ) || Array.from(mutation.removedNodes).some(node => 
                    node.nodeType === 1 && (
                        node.matches('table.table.table-striped.table-bordered:not(.bg-gray)') ||
                        node.querySelector('table.table.table-striped.table-bordered:not(.bg-gray)') ||
                        (node.matches('tbody') && node.closest('table.table.table-striped.table-bordered:not(.bg-gray)') &&
                         Array.from(node.querySelectorAll('tr')).some(tr => !tr.classList.contains('row-hits'))) ||
                        (node.matches('tr:not(.row-hits)') && node.closest('table.table.table-striped.table-bordered:not(.bg-gray)'))
                    )
                );

                // Проверяем добавление подтаблиц
                const subTableChanged = Array.from(mutation.addedNodes).some(node => 
                    node.nodeType === 1 && (
                        node.matches('tr.row-hits') || 
                        node.querySelector('tr.row-hits') ||
                        node.matches('table.bg-gray') ||
                        node.querySelector('table.bg-gray')
                    )
                );

                if (mainTableChanged) {
                    tableChanged = true;
                }
                if (subTableChanged) {
                    subtableAdded = true;
                }
            }
        }

        if (tableChanged) {
            console.log('Обнаружено изменение в главной таблице, запускаем initGeoLookup.');
            initGeoLookup();
        } else if (subtableAdded) {
            adjustSubtableColspan();
        }
    });

    observer.observe(targetNode, {
        childList: true,
        subtree: true
    });

    console.log('MutationObserver запущен, отслеживаем #tabContentVisits.');
})();
